#! /bin/python

import re
import sys
import pytricks  # https://github.com/HSwift/pytricks
import os
import functools
import inspect
import json


def str_escaping(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        res = func(*args, **kwargs)
        try:
            return res.str()
        except:
            return repr(res)[2:-1]
    return wrapper


def return_as_name(func):
    if len(inspect.getfullargspec(inspect.unwrap(func)).args) > 1:
        raise Exception(f"{func.__name__} can only have one argument")
    func.return_as_name = True

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper


class Encoder():
    @str_escaping
    @staticmethod
    def base64(i):
        return i.base64()

    @str_escaping
    @staticmethod
    def base64Decode(i):
        return i.unbase64()

    @str_escaping
    @staticmethod
    def hex(i):
        return i.hex()

    @str_escaping
    @staticmethod
    def hexDecode(i):
        return i.unhex()

    @str_escaping
    @staticmethod
    def url(i):
        return i.urlencode()

    @str_escaping
    @staticmethod
    def urlDecode(i):
        return i.urldecode()

    @str_escaping
    @staticmethod
    def urlAll(i):
        return i.ascii_format("%%%02x", "")

    @str_escaping
    @staticmethod
    def hexEscape(i):
        return i.ascii_format("\\x%02x", "")

    @str_escaping
    @staticmethod
    def html(i):
        return i.ascii_format("&#x%02x;", "")

    @str_escaping
    @staticmethod
    def htmlDecode(i):
        return i.htmlunescape()

    @str_escaping
    @staticmethod
    def unescape(i):
        return i.encode('latin1').decode('unicode-escape')

    @str_escaping
    @staticmethod
    def pyeval(i):
        return str(eval(i))

    @str_escaping
    @staticmethod
    def pyexec(i):
        from io import StringIO
        from contextlib import redirect_stdout
        f = StringIO()
        with redirect_stdout(f):
            exec(i)
        s = f.getvalue()
        return s

    @str_escaping
    @staticmethod
    def replace(i, word, to):
        word = word.encode('latin1').decode('unicode-escape')
        to = to.encode('latin1').decode('unicode-escape')
        return i.replace(word, to)

    @str_escaping
    @staticmethod
    def regexReplace(i, regex, to):
        to = to.encode('latin1').decode('unicode-escape')
        return re.sub(regex, to, i)

    @str_escaping
    @staticmethod
    def remove(i, word):
        word = word.encode('latin1').decode('unicode-escape')
        return i.replace(word, '')

    @str_escaping
    @staticmethod
    def regexRemove(i, regex):
        return re.sub(regex, '', i)

    @str_escaping
    @staticmethod
    def regexFind(i, regex):
        t = re.findall(regex, i)
        if len(t) == 0:
            return ""
        else:
            return t[0]

    @str_escaping
    @staticmethod
    def regexFindAll(i, regex, sep):
        t = re.findall(regex, i)
        if len(t) == 0:
            return ""
        else:
            return sep.join(t)

    @str_escaping
    @staticmethod
    def asciiformat(i, format):
        return i.ascii_format(format, '')

    @staticmethod
    def unicode(i):
        return i.unicode_escape()

    @return_as_name
    @staticmethod
    def getLen(i):
        return f"len: {len(i)}"

    @staticmethod
    def uuid(i):
        import uuid
        return str(uuid.uuid4())

    @staticmethod
    def random(i, length):
        import string
        import random
        return ''.join(random.sample(string.ascii_letters + string.digits, int(length)))

    @staticmethod
    def jsonFormat(i):
        import json
        t = json.loads(i)
        return json.dumps(t, indent=4, ensure_ascii=False)

    @staticmethod
    def md5(i):
        return i.md5()

    @staticmethod
    def qs2json(data):
        try:
            from querystring_parser import parser
            parse = parser.parse
        except:
            from urllib.parse import parse_qs as parse
        import json
        data = parse(data)
        return json.dumps(data)

    @staticmethod
    def json2yaml(data):
        import json
        import yaml
        return yaml.dump(json.loads(data), default_flow_style=False, allow_unicode=True, width=2147483647)

    @staticmethod
    def yaml2json(data):
        import json
        import yaml
        return json.dumps(yaml.load(data, Loader=yaml.CLoader), indent=4, ensure_ascii=False)

    @staticmethod
    def substring(data,start,end):
        start = int(start)
        end = int(end)
        return data[start:end]

    @staticmethod
    def regexEscape(data):
        import re
        return re.escape(data)

    @staticmethod
    def upper(data):
        return data.upper()

    @staticmethod
    def lower(data):
        return data.lower()

    @staticmethod
    def hex2url(data):
        return data.unhex().urlencode()

    @staticmethod
    def ord(data):
        return str(ord(data))

    @staticmethod
    def chr(data):
        return chr(int(data))

user_input = os.popen("xclip -sel clip -o").read()
if len(sys.argv) > 1:
    name = sys.argv[1]
    if name.startswith("error"):
        exit()
    if os.environ.get('ROFI_DATA') != None:
        data = os.environ.get('ROFI_DATA')
        data = json.loads(data)
        data["values"].append(name)
        name = data["func"]
    else:
        data = {"func": name, "values": []}
    try:
        encoder = getattr(Encoder, name)
        args = inspect.getfullargspec(inspect.unwrap(encoder)).args
        if len(args) == 1 or (len(data["values"]) + 1) == len(args):
            result = encoder(user_input, *data["values"])
            os.system("echo '%s'| base64 -d | xclip -f -r -sel c > /dev/null" %
                      result.base64().str())
            if os.environ.get("ROFI_RETV") == None:
                print(result)
        else:
            arg_name = args[len(data["values"]) + 1]
            print(f"\x00prompt\x1f{arg_name}")
            print(f"\x00data\x1f{json.dumps(data)}")
            print(f"\x00no-custom\x1ffalse")
            print(f" \x00nonselectable\x1ftrue")
    except Exception as e:
        print("error:", e)

else:
    user_input_striped = user_input[:50] + (user_input[50:] and ' ...')
    print(f"\x00message\x1f<b>input: </b>{repr(user_input_striped.htmlescape())[1:-1]}\n")
    for encoder in dir(Encoder):
        if hasattr(getattr(Encoder, encoder), 'return_as_name'):
            result = getattr(Encoder, encoder)(user_input)
            print(f"@{result}\x00nonselectable\x1ftrue\n")
    for encoder in dir(Encoder):
        if (not callable(getattr(Encoder, encoder))) or encoder.startswith("__") or hasattr(getattr(Encoder, encoder), 'return_as_name'):
            continue
        print(encoder)
